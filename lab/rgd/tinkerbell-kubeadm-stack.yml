apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: tinkerbellkubeadmstack.v1alpha1.kro.run
spec:
  schema:
    apiVersion: v1alpha1
    kind: TinkerbellKubeadmStack
    spec:
      tinkerbellIP: string
      sourceInterface: string | default=virbr0
      trustedProxies: string | default=10.244.0.0/16
      versions:
        tinkerbellProvider: string | default=v0.6.8
        tinkerbellChart: string | default=v0.22.1
        kubeVip: string | default=v1.0.3
        kubeVipCloudProvider: string | default=0.0.12
      isoURL: string | default=https://github.com/tinkerbell/hook/releases/download/latest/hook-x86_64-efi-initrd.iso
      rufioMetricsAddr: string | default=0.0.0.0:8085
      tinkControllerMetricsAddr: string | default=0.0.0.0:8084
      osiePort: integer | default=7171
      kubevip:
        enabled: boolean | default=false
        lbEnable: boolean | default=false
    status:
      infrastructureProviderReady: ${infrastructureProvider.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
      tinkerbellReleaseReady: ${tinkerbellRelease.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
      kubeVipReleaseReady: '${kubeVipRelease.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}'
  resources:
    # Tinkerbell Config Secret
    - id: tinkerbellSecret
      template:
        apiVersion: v1
        kind: Secret
        metadata:
          name: tinkerbell-infrastructure-provider-config
          namespace: ${schema.metadata.namespace}
        type: Opaque
        stringData:
          TINKERBELL_IP: ${schema.spec.tinkerbellIP}

    # Infrastructure Provider (Tinkerbell)
    - id: infrastructureProvider
      readyWhen:
        - ${infrastructureProvider.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
      template:
        apiVersion: operator.cluster.x-k8s.io/v1alpha2
        kind: InfrastructureProvider
        metadata:
          name: tinkerbell
          namespace: ${schema.metadata.namespace}
        spec:
          configSecret:
            name: ${tinkerbellSecret.metadata.name}
            namespace: ${schema.metadata.namespace}
          fetchConfig:
            url: https://github.com/tinkerbell/cluster-api-provider-tinkerbell/releases/${schema.spec.versions.tinkerbellProvider}/infrastructure-components.yaml
          version: ${schema.spec.versions.tinkerbellProvider}

    # Tinkerbell Helm Repository
    - id: tinkerbellRepo
      template:
        apiVersion: source.toolkit.fluxcd.io/v1
        kind: HelmRepository
        metadata:
          name: tinkerbell
          namespace: ${schema.metadata.namespace}
        spec:
          provider: generic
          type: oci
          url: oci://ghcr.io/tinkerbell/charts

    # Tinkerbell Helm Release
    - id: tinkerbellRelease
      readyWhen:
        - ${tinkerbellRelease.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
      template:
        apiVersion: helm.toolkit.fluxcd.io/v2
        kind: HelmRelease
        metadata:
          name: tinkerbell
          namespace: ${schema.metadata.namespace}
        spec:
          interval: 10m
          chart:
            spec:
              chart: tinkerbell
              version: ${schema.spec.versions.tinkerbellChart}
              reconcileStrategy: ChartVersion
              sourceRef:
                kind: HelmRepository
                name: ${tinkerbellRepo.metadata.name}
                namespace: ${schema.metadata.namespace}
          values:
            artifactsFileServer: http://${schema.spec.tinkerbellIP}:7173
            publicIP: ${schema.spec.tinkerbellIP}
            trustedProxies:
              - ${schema.spec.trustedProxies}
            deployment:
              envs:
                globals:
                  logLevel: 3
                rufio:
                  metricsAddr: ${schema.spec.rufioMetricsAddr}
                smee:
                  ipxeHttpScriptBindAddr: ${schema.spec.tinkerbellIP}
                  isoUpstreamURL: ${schema.spec.isoURL}
                  osieURL: http://${schema.spec.tinkerbellIP}:${string(schema.spec.osiePort)}
                  syslogBindAddr: ${schema.spec.tinkerbellIP}
                  tftpServerBindAddr: ${schema.spec.tinkerbellIP}
                tinkController:
                  metricsAddr: ${schema.spec.tinkControllerMetricsAddr}
                tinkServer:
                  bindAddr: ${schema.spec.tinkerbellIP}
                tootles:
                  bindAddr: ${schema.spec.tinkerbellIP}
              hostNetwork: true
              init:
                sourceInterface: ${schema.spec.sourceInterface}
            optional:
              hookos:
                enabled: true
                hostNetwork: true
              kubevip:
                enabled: ${schema.spec.kubevip.enabled}
                image: ghcr.io/kube-vip/kube-vip:${schema.spec.versions.kubeVip}
                additionalEnv:
                  - name: lb_enable
                    value: "${schema.spec.kubevip.lbEnable}"
                  - name: vip_interface
                    value: ${schema.spec.sourceInterface}

    # Kube-VIP Helm Repository
    - id: kubeVipRepo
      includeWhen:
        - ${schema.spec.kubevip.enabled}
      template:
        apiVersion: source.toolkit.fluxcd.io/v1
        kind: HelmRepository
        metadata:
          name: kube-vip
          namespace: ${schema.metadata.namespace}
        spec:
          interval: 10m
          url: https://kube-vip.github.io/helm-charts

    # Kube-VIP Cloud Provider ConfigMap (initial/placeholder)
    # This ensures the configmap exists before the controller starts.
    # The hosted-cluster RGD will update this with actual IP ranges.
    - id: kubeVipConfigMap
      includeWhen:
        - ${schema.spec.kubevip.enabled}
      template:
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: kube-vip-cloud-provider
          namespace: ${schema.metadata.namespace}
        data: {}

    # Kube-VIP Cloud Provider Helm Release
    - id: kubeVipRelease
      includeWhen:
        - ${schema.spec.kubevip.enabled}
      readyWhen:
        - ${kubeVipRelease.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
      template:
        apiVersion: helm.toolkit.fluxcd.io/v2
        kind: HelmRelease
        metadata:
          name: kube-vip-cloud-provider
          namespace: ${kubeVipConfigMap.metadata.namespace}
        spec:
          interval: 10m
          chart:
            spec:
              chart: kube-vip-cloud-provider
              version: ${schema.spec.versions.kubeVipCloudProvider}
              sourceRef:
                kind: HelmRepository
                name: ${kubeVipRepo.metadata.name}
                namespace: ${schema.metadata.namespace}
